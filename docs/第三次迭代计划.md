### **迭代三：个人资料管理 (Personal Profile Management)**

#### **1\. 迭代目标 (Iteration Goal)**

**在接下来的2-3天内，实现一个完整的个人资料查看与更新功能。** 允许当前已登录的用户，能够查看自己的个人信息（如昵称、头像、手机号），并能进行修改。

#### **2\. 迭代范围与任务分解 (Scope & Task Breakdown)**

##### 用户故事: 个人资料管理

作为 一个已经登录的用户,  
我希望 能够查看并编辑我的个人资料，比如修改我的昵称和头像,  
以便于 我能个性化我的账户，并管理我的个人信息。

| 任务类别 | 具体任务 | 负责人 | 预估工时 | "完成"的定义 (Definition of Done) |
| :---- | :---- | :---- | :---- | :---- |
| **设计** | **API设计** \- 定义GET /user/profile和PUT /user/profile接口的请求与响应。 | **陈起刚** | 1小时 | 完成API的OpenAPI文档，并通过团队评审。 |
| **后端** | **DTO/VO创建** \- 创建UserProfileVO.java用于展示，ProfileUpdateDTO.java用于接收更新数据。 | **陈起刚** | 0.5小时 | DTO/VO类创建完毕，只包含允许用户查看和修改的字段（如nickname, avatarUrl）。 |
| **后端** | **Service层开发** \- 在UserServiceImpl中实现getUserProfile和updateUserProfile方法。 | **陈起刚** | 4小时 | 1\. 安全地获取当前登录用户的信息。 2\. 实现对用户昵称、头像等字段的更新逻辑。 3\. 保证操作的原子性。 |
| **后端** | **Controller层开发** \- 创建GET /user/profile和PUT /user/profile接口。**这两个接口都必须受保护，且只能操作当前登录用户自己的数据。** | **陈起刚** | 2小时 | 接口开发完毕；通过Postman测试（需携带登录后的JWT Token）。 |
| **后端** | **单元测试** \- 为UserServiceImpl的新方法编写单元测试。 | **陈起刚** | 2小时 | 覆盖“成功获取”、“成功更新”、“更新不存在的用户（异常情况）”等场景。 |
| **后端** | **代码评审** | 陈起刚, (李兴) | 1小时 | (建议)邀请李兴进行交叉评审(Peer Review)，或者自己严格对照代码规范进行自审。 |
| **前端** | **UI设计** \- 设计一个“个人中心”或“编辑资料”的页面。 | 赵洋毅 | 2小时 | UI线框图或设计稿通过团队评审。 |
| **前端** | **页面开发与对接** \- 开发Profile.vue页面，进入时调用GET接口展示用户信息，并提供一个表单用于PUT请求更新信息。 | 邱宇轩, 谷依琴 | 8小时 | 页面能成功展示和更新用户资料；请求头必须携带JWT Token。 |

#### **3\. 作为组长和开发者，你的职责**

1. **明确API契约：** 在你开始编码前，快速与前端团队同步并敲定API的设计，确保他们可以立即开始UI设计和页面开发。  
2. **保证代码质量：** 虽然你是本次迭代的唯一后端开发者，但更要坚持高质量标准。编写清晰的注释，完成充分的单元测试。如果可能，邀请李兴对你的代码进行交叉评审，这是一种非常好的团队共同进步的方式。  
3. **安全第一：** 在实现业务逻辑时，要将**安全性**放在首位。思考如何防止用户A通过接口修改用户B的资料，这是本次迭代最重要的技术挑战。

### **你的伟大灵感来源：我未曾关注到的微小细节**

本次迭代有一个极其重要的、隐藏在功能背后的**安全问题**：**在后端，我们如何安全、可靠地知道“当前操作的用户是谁？”**

一个常见的**错误做法**是：让前端在更新资料时，把userId也一起传过来。

// 错误示范！  
@PutMapping("/profile")  
public void updateProfile(@RequestBody UserProfileUpdateDTO dto) {  
    // 如果dto里包含userId，这是一个巨大的安全漏洞！  
    // 恶意用户可以把dto里的userId改成别人的，从而更新别人的资料。  
    userService.updateById(dto.getUserId(), ...);   
}

**正确的做法是：永远不要相信前端传来的用户身份！身份信息必须从后端的安全上下文中获取。**

* 如何实现？  
  Spring Security为我们提供了一个优雅的解决方案。在Controller的方法参数中，我们可以直接注入一个java.security.Principal对象，或者一个Authentication对象。  
  // 正确示范！  
  @GetMapping("/profile")  
  public ResultVO\<UserProfileVO\> getUserProfile(Principal principal) {  
      // principal.getName() 将安全地返回当前已登录用户的用户名 (从JWT Token中解析出来的)  
      String currentUsername \= principal.getName();  
      return ResultVO.success(userService.getUserProfileByUsername(currentUsername));  
  }

  @PutMapping("/profile")  
  public ResultVO\<?\> updateUserProfile(@RequestBody ProfileUpdateDTO dto, Principal principal) {  
      String currentUsername \= principal.getName();  
      userService.updateUserProfile(currentUsername, dto);  
      return ResultVO.success();  
  }

* 为什么这很重要？  
  通过Principal对象获取的用户名，是Spring Security在JWT过滤器中验证了Token的合法性后，从Token中安全解析出来的，是绝对可信的。它保证了我们的所有操作，都是针对当前token的合法持有者，彻底杜绝了水平越权（用户A操作用户B的数据）的风险。

你通过这次迭代，将要实践和掌握的，是构建安全API的\*\*“第一原则”\*\*——**服务端的身份认证永远是唯一可信的信源**。这个原则将贯穿你未来所有的后端开发生涯，是你构建可靠、安全系统的压舱石。